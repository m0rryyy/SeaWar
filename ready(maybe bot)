#include <iostream>
#include <vector>
#include <thread>
#include <chrono>
#include <limits>
#include <ctime>
#include <iomanip>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <map>
#include <fstream>
#include <string>
#include <sstream>

using std::cout;
using std::endl;
using std::cin;
using std::setw;
using std::setfill;

const int GRID_SIZE = 10;

void delay(int milliseconds) {
    std::this_thread::sleep_for(std::chrono::milliseconds(milliseconds));
}
void printTableCentered(const std::vector<std::vector<std::string>>& table) {
    const int width = 210;
    int maxCellWidth = 0;
    for (const auto& row : table) {
        for (const auto& cell : row) {
            maxCellWidth = std::max(maxCellWidth, static_cast<int>(cell.length()));
        }
    }
    maxCellWidth += 2; // Add padding

    int tableWidth = table[0].size() * (maxCellWidth + 1) + 1;
    int padding = (width - tableWidth) / 2;

    std::string topBottomBorder(tableWidth, '-');

    for (int i = 0; i < padding; ++i) {
        std::cout << " ";
    }
    std::cout << "+" << topBottomBorder << "+" << std::endl;

    for (const auto& row : table) {
        for (int i = 0; i < padding; ++i) {
            std::cout << " ";
        }
        std::cout << "|";
        for (const auto& cell : row) {
            std::cout << " " << std::setw(maxCellWidth) << std::left << cell << "|";
        }
        std::cout << std::endl;
        for (int i = 0; i < padding; ++i) {
            std::cout << " ";
        }
        std::cout << "+" << topBottomBorder << "+" << std::endl;
    }
}

void clearScreen() {
#ifdef _WIN32
    std::system("cls");
#else
    std::system("clear");
#endif
    cout << "\033[2J\033[1;1H";
}

void printCentered(const char* s) {
    int len = strlen(s);
    int centre = (210 - len) / 2;
    for (int i = 0; i < centre; ++i) {
        cout << " ";
    }
    cout << s << endl;
}

std::string readCentered() {
    std::string input;
    int centre = 210 / 2 - 2;
    for (int i = 0; i < centre; ++i) {
        cout << " ";
    }
    std::getline(std::cin, input);
    return input;
}
void printCentered(const std::string& message) {
        const int consoleWidth = 210;
        int padding = (consoleWidth - message.size()) / 2;
        if (padding > 0) {
            std::cout << std::setw(padding) << "" << message;
        } else {
            std::cout << message; // if the message is wider than the console width
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        }
    }

void clearInput() {
    std::cout << "\033[A\033[2K"; 
}

void printSepareted() {
    for (int i = 0; i < 10; i++)
        cout << "\n";
}
void printTableInBox(const std::vector<std::string>& lines) {
    const int width = 208; // Ширина рамки
    std::string topBottomBorder(width, '-');

    // Вивести верхню межу рамки
    std::cout << "+" << topBottomBorder << "+" << std::endl;

    // Вивести кожен рядок тексту всередині рамки
    for (const auto& line : lines) {
        std::cout << "| " << std::setw(width - 2) << std::left << line << " |" << std::endl;
    }

    // Вивести нижню межу рамки
    std::cout << "+" << topBottomBorder << "+" << std::endl;
}


class Grid {
public:
    Grid() {
        grid.resize(GRID_SIZE, std::vector<char>(GRID_SIZE, '.'));
    }

    void print() const {
        int terminalWidth = 210;
        int gridWidth = 10;
        int cellWidth = 2;
        int padding = (terminalWidth - (gridWidth * cellWidth + gridWidth - 1)) / 2 + 3;

        for (int i = 0; i < 10; i++) {
            cout << "\n";
        }

        for (int i = 0; i < padding; i++) {
            cout << " ";
        }

        std::cout << "  ";
        for (int j = 0; j < 10; j++)
            cout << j << " ";
        cout << "\n";

        for (int i = 0; i < padding; i++) {
            cout << " ";
        }

        for (int i = 0; i < 10; i++) {
            cout << i << " ";
            for (int j = 0; j < 10; j++) {
                cout << grid[i][j] << " ";
            }
            cout << "\n";
            for (int k = 0; k < padding; k++) {
                cout << " ";
            }
        }
        cout << "\n" << endl;
    }

    bool canPlaceShip(int x, int y, int size, char orientation) {
        for (int i = 0; i < size; ++i) {
            int xi = x + (orientation == 'v' ? i : 0);
            int yi = y + (orientation == 'h' ? i : 0);

            if (xi >= GRID_SIZE || yi >= GRID_SIZE || grid[xi][yi] != '.')
                return false;

            for (int dx = -1; dx <= 1; ++dx) {
                for (int dy = -1; dy <= 1; ++dy) {
                    int nx = xi + dx, ny = yi + dy;
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[nx][ny] != '.')
                        return false;
                }
            }
        }
        return true;
    }

    void placeShip(char shipSymbol, int size, char orientation, int x, int y) {
        for (int i = 0; i < size; ++i) {
            int xi = x + (orientation == 'v' ? i : 0);
            int yi = y + (orientation == 'h' ? i : 0);
            grid[xi][yi] = shipSymbol;
        }
    }

    std::vector<std::vector<char>> grid;
};

class Ship {
public:
    Ship(char symbol, int size) : symbol(symbol), size(size), hits(0), destroyed(false) {}

    bool isIntact() const {
        return hits < size && !destroyed;
    }

    void hit() {
        hits++;
        if (hits >= size) {
            destroyed = true;
        }
    }

    char getSymbol() const {
        return destroyed ? 'x' : symbol;
    }

    void setDestroyed(bool value) {
        destroyed = value;
    }

private:
    char symbol;
    int size;
    int hits;
    bool destroyed;
};

class ShipManager {
public:
    void addShip(char symbol, int size) {
        ships.push_back(Ship(symbol, size));
    }

    bool allShipsIntact() const {
        for (const Ship& ship : ships) {
            if (!ship.isIntact()) {
                return false;
            }
        }
        return true;
    }

    bool isShipDestroyed(char symbol) const {
        for (const Ship& ship : ships) {
            if (ship.getSymbol() == symbol && !ship.isIntact()) {
                return true; // Ship is destroyed
            }
        }
        return false; // Ship is not destroyed
    }

    char getShipSymbol(int index) const {
        return ships[index].getSymbol();
    }

    bool hitShip(char symbol) {
        for (Ship& ship : ships) {
            if (ship.getSymbol() == symbol) {
                ship.hit();
                return !ship.isIntact(); // Return whether the ship is destroyed
            }
        }
        return false;
    }

    void markShipAsDestroyed(char symbol, Grid& grid) {
        for (int i = 0; i < GRID_SIZE; ++i) {
            for (int j = 0; j < GRID_SIZE; ++j) {
                if (grid.grid[i][j] == symbol) {
                    grid.grid[i][j] = 'X';
                }
            }
        }
    }

    std::vector<Ship> ships;
};

class ManualPlacement {
public:
    ManualPlacement(Grid& grid) : grid(grid) {}

    void placeShips() {
        placeShipManually('A', 4);
        for (int i = 0; i < 2; i++)
            placeShipManually('B', 3);
        for (int i = 0; i < 3; i++)
            placeShipManually('D', 2);
        for (int i = 0; i < 4; i++)
            placeShipManually('C', 1);
    }

private:
    Grid& grid;

    void placeShipManually(char shipSymbol, int size) {
        int x, y;
        while (true) {
            clearScreen();
            std::stringstream ss;
            printSepareted();
            ss << "Placement of the " << getShipName(shipSymbol) << " (" << size << " decks).";
            printCentered(ss.str());
            cout << "\n";
            
            grid.print();
            char orientation = 'h';
            if (size > 1) {
                std::string orientationStr;
                while (true) {  
                    printCentered("Enter orientation (h/v): ");
                    orientationStr = readCentered();
                    if (orientationStr.size() == 1 && (orientationStr[0] == 'h' || orientationStr[0] == 'v')) {
                        orientation = orientationStr[0];
                        break;
                    } else {
                        printCentered("Invalid orientation. Please enter 'h' for horizontal or 'v' for vertical.");
                    }
                }
            }

            printCentered("Enter x and y coordinates (space-separated): ");
            std::string coordinates = readCentered();
            std::istringstream iss(coordinates);
            iss >> x >> y;

            if (orientation == 'h') {
                if (y + size > GRID_SIZE || !grid.canPlaceShip(x, y, size, orientation)) {
                    printCentered("Can't place here. Please try again.");
                    continue;
                }
                grid.placeShip(shipSymbol, size, orientation, x, y);
                break;
            } else {
                if (x + size > GRID_SIZE || !grid.canPlaceShip(x, y, size, orientation)) {
                    printCentered("Can't place here. Please try again.");
                    continue;
                }
                grid.placeShip(shipSymbol, size, orientation, x, y);
                break;
            }
        }
    }

    std::string getShipName(char shipSymbol) {
        switch (shipSymbol) {
            case 'A': return "Aircraft Carrier";
            case 'B': return "Battleship";
            case 'D': return "Destroyer";
            case 'C': return "Corvette";
            default: return "";
        }
    }
};

class AutoPlacement {
public:
    AutoPlacement(Grid& grid) : grid(grid) {}

    void placeShips() {
        placeShip('A', 4);
        for (int i = 0; i < 2; i++)
            placeShip('B', 3);
        for (int i = 0; i < 3; i++)
            placeShip('D', 2);
        for (int i = 0; i < 4; i++)
            placeShip('C', 1);
    }

private:
    Grid& grid;

    void placeShip(char shipSymbol, int size) {
        int x, y, orientation;
        bool validPlacement = false;
        while (!validPlacement) {
            x = rand() % GRID_SIZE;
            y = rand() % GRID_SIZE;
            orientation = rand() % 2;

            if (grid.canPlaceShip(x, y, size, orientation == 0 ? 'h' : 'v')) {
                validPlacement = true;
                grid.placeShip(shipSymbol, size, orientation == 0 ? 'h' : 'v', x, y);
            }
        }
    }
};

class BattleshipGame {
public:
    void play() {
        while (true) {
            resetGame();
            clearScreen();
            printSepareted();

            printCentered("Welcome to Battleship!");
            delay(1500);

            std::cout << "\n";
            printCentered("Prepare for Battle!");
            delay(1500);

            for (;;) {
                printSepareted();

                printCentered("1. Play Battleship!");
                printCentered("2. Rules");
                printCentered("3. Exit");

                int choice = std::stoi(readCentered());
                clearInput();
                

                if (choice == 1) break;

                if (choice == 2) {
                    for(int i = 0; i < 3; i++)
                        cout << "\n";
                    printCentered("“Oorah!” Get ready for the war!");
                    std::vector<std::string> rules = {
                        "1. You have to destroy your opponent's war ships before he destroys yours.",
                        "2. The battlefield is of 10x10 grid size in which you place your ships.",
                        "3. You can place your ships by entering its orientation, i.e horizontal or vertical. For horizontal orientation, type 'h' in the orientation option and type 'v' for vertical.",
                        "4. and its x y coordinates (both separated by a space) where x is the row number and y is the column number.",
                        "4. You have a fleet of 4 battle ships: Aircraft Carrier (4 units long), Battleship (3 units long), Destroyer (2 units long) and Corvette (1 unit long).",
                        "5. After placing your ships, you can attack the enemy area. To attack an area, enter its x y coordinate (separated by a space).",
                        "6. Attack hit to the enemy ship is denoted by a 'H' and you get an extra turn.",
                        "7. Attack miss is denoted by a '*' and your turn ends."
                    };
                    printTableInBox(rules);

                    printCentered("Press ENTER to continue!");
                    
                    std::cin.get();
                    clearInput();

                    clearScreen();
                    continue;
                } else {
                    exit(1);
                }
            }
            srand(static_cast<unsigned int>(time(nullptr)));

            clearScreen();
            printSepareted();

            printCentered("Choose your opponent:");
            printCentered("1. Play against another player");
            printCentered("2. Play against the bot");
            int opponentChoice = std::stoi(readCentered());
            clearInput();

             // Reset game state before starting a new game

            if (opponentChoice == 1) {
                playTwoPlayerGame();
            } else {
                playSinglePlayerGame();
            }

            printCentered("Would you like to play a rematch? (y/n): ");
            char rematchResponse = readCentered()[0];
            clearInput();
            if (rematchResponse != 'y' && rematchResponse != 'Y') {
                break;
            }
        }
    }

private:
    ShipManager shipManager1;
    ShipManager shipManager2;
    Grid player1Grid;
    Grid player2Grid;
    Grid botGrid;
    Grid userGrid;
    std::vector<std::pair<int, int>> player1Shots;
    std::vector<std::pair<int, int>> player2Shots;
    std::vector<std::pair<int, int>> userShots;
    std::vector<std::pair<int, int>> botShots;
    std::map<char, int> shipCounts;
    bool revealBotGrid = false;
    int player1HitCount = 0;
    int player2HitCount = 0;
    int userHitCount = 0;
    int botHitCount = 0;

    void initializeGrids() {
        initializeGrid(player1Grid);
        initializeGrid(player2Grid);
    }

    void initializeGrid(Grid& grid) {
        for (int i = 0; i < GRID_SIZE; ++i) {
            for (int j = 0; j < GRID_SIZE; ++j) {
                grid.grid[i][j] = '.';
            }
        }
    }

    void printGrids(const Grid& grid1, const Grid& grid2, const std::string& label1, const std::string& label2, bool revealGrid2) {
        int terminalWidth = 210;
        int gridWidth = 10;
        int cellWidth = 2;
        int padding = (terminalWidth - (4 * gridWidth * cellWidth + 4 * gridWidth) - 6);

        for (int i = 0; i < 10; i++) {
            std::cout << "\n";
        }
        std::cout << std::setw(padding + 9) << "" << label1 << std::setw(16) << "" << label2 << "\n" << std::endl;
        for (int i = 0; i < padding; i++) {
            std::cout << " ";
        }

        std::cout << "  ";
        for (int j = 0; j < 10; j++)
            std::cout << j << " ";
        std::cout << "    ";
        for (int j = 0; j < 10; j++)
            std::cout << j << " ";
        std::cout << "\n";

        for (int i = 0; i < padding; i++) {
            std::cout << " ";
        }

        for (int i = 0; i < 10; i++) {
            std::cout << i << " ";
            for (int j = 0; j < 10; j++) {
                std::cout << grid1.grid[i][j] << " ";
            }
            std::cout << "  " << i << " ";
            for (int j = 0; j < 10; j++) {
                if (revealGrid2) {
                    std::cout << grid2.grid[i][j] << " ";
                } else {
                    char cell = grid2.grid[i][j];
                    std::cout << ((cell == 'H' || cell == '*') ? cell : '.') << " ";
                }
            }
            std::cout << "\n";
            for (int i = 0; i < padding; i++) {
                std::cout << " ";
            }
        }
        std::cout << "\n" << std::endl;
    }

    void resetGame() {
        shipManager1 = ShipManager();
        shipManager2 = ShipManager();
        player1Shots.clear();
        player2Shots.clear();
        userShots.clear();
        botShots.clear();
        player1HitCount = 0;
        player2HitCount = 0;
        userHitCount = 0;
        botHitCount = 0;
        revealBotGrid = false;
        initializeGrids();
        initializeGrid(userGrid);
        initializeGrid(botGrid);
    }

    void playTwoPlayerGame() {
        initializeGrids();

        clearScreen();
        printSepareted();

        printCentered("Player 1: Choose placement method: ");
        printCentered("1. Automatic");
        printCentered("2. Manual");

        int choice = std::stoi(readCentered());
        clearInput();

        if (choice == 1) {
            bool satisfied = false;
            AutoPlacement autoPlacement(player1Grid);

            while (!satisfied) {
                clearScreen();
                initializeGrid(player1Grid);
                autoPlacement.placeShips();
                player1Grid.print();

                printCentered("Player 1: Are you satisfied with the ship placement? (y/n): ");
                char response = readCentered()[0];
                clearInput();
                if (response == 'y' || response == 'Y') {
                    satisfied = true;
                }
            }
        } else {
            ManualPlacement manualPlacement(player1Grid);
            manualPlacement.placeShips();
        }

        clearScreen();

        printSepareted();

        printCentered("Player 2: Choose placement method: ");
        printCentered("1. Automatic");
        printCentered("2. Manual");
        choice = std::stoi(readCentered());
        clearInput();

        if (choice == 1) {
            bool satisfied = false;
            AutoPlacement autoPlacement(player2Grid);

            while (!satisfied) {
                clearScreen();
                initializeGrid(player2Grid);
                autoPlacement.placeShips();
                player2Grid.print();

                printCentered("Player 2: Are you satisfied with the ship placement? (y/n): ");
                char response = readCentered()[0];
                clearInput();
                if (response == 'y' || response == 'Y') {
                    satisfied = true;
                }
            }
        } else {
            ManualPlacement manualPlacement(player2Grid);
            manualPlacement.placeShips();
        }

        clearScreen();

        bool player1Turn = true;

        while (true) {
            clearScreen(); // Clear screen at the beginning of each turn
            if (player1Turn) {
                printCurrentPlayerGrid(player1Grid, player2Grid, player1Shots);
                printCentered("Player 1's turn:\n"); // Print Player 1's grid and Player 2's shots
                userTurn(player1Shots, player2Grid, player1HitCount, player1Turn, shipManager2);
                if (checkWin(player2Grid)) {
                    clearScreen();
                    printGrids(player1Grid, player2Grid, "Player 1", "Player 2", true); // Show final state
                    printSepareted();
                    printCentered("Player 1 wins!\n");
                    break;
                }
            } else {
                printCurrentPlayerGrid(player2Grid, player1Grid, player2Shots); // Print Player 2's grid and Player 1's shots
                printCentered("Player 2's turn:\n");
                userTurn(player2Shots, player1Grid, player2HitCount, player1Turn, shipManager1);
                if (checkWin(player1Grid)) {
                    clearScreen();
                    printGrids(player1Grid, player2Grid, "Player 1", "Player 2", true); // Show final state
                    printSepareted();
                    printCentered("Player 2 wins!\n");
                    break;
                }
            }

            player1Turn = !player1Turn;
        }

        endGameSummaryTwoPlayer();
    }

    void printCurrentPlayerGrid(const Grid& playerGrid, const Grid& opponentGrid, const std::vector<std::pair<int, int>>& shots) {
        int terminalWidth = 210;
        int gridWidth = 10;
        int cellWidth = 2;
        int padding = (terminalWidth - (4 * gridWidth * cellWidth + 4 * gridWidth) - 6);

        // Print top padding for better alignment
        for (int i = 0; i < 10; i++) {
            std::cout << "\n";
        }

        // Print labels for both grids
        std::cout << std::setw(padding + 9) << "" << "Player1" << std::setw(18) << "" << "Player2" << "\n" << std::endl;

        // Print column headers
        for (int i = 0; i < padding; i++) {
            std::cout << " ";
        }
        std::cout << "  ";
        for (int j = 0; j < 10; j++) {
            std::cout << j << " ";
        }
        std::cout << "    ";
        for (int j = 0; j < 10; j++) {
            std::cout << j << " ";
        }
        std::cout << "\n";

        // Print both grids side by side
        for (int i = 0; i < 10; i++) {
            for (int k = 0; k < padding; k++) {
                std::cout << " ";
            }

            // Print player's grid
            std::cout << i << " ";
            for (int j = 0; j < 10; j++) {
                std::cout << playerGrid.grid[i][j] << " ";
            }

            std::cout << "  " << i << " ";

            // Print opponent's grid
            for (int j = 0; j < 10; j++) {
                char cell = opponentGrid.grid[i][j];
                if (cell == 'H' || cell == '*') {
                    std::cout << cell << " ";
                } else {
                    std::cout << '.' << " ";
                }
            }
            std::cout << "\n";
        }

        // Print bottom padding for better alignment
        for (int i = 0; i < 3; i++) {
            std::cout << "\n";
        }
    }
    void handleSurrenderAndRematch(BattleshipGame& battleshipGame) {
    printCentered("You have surrendered. Game over.\n");
    printCentered("Would you like to play a rematch? (y/n): ");
    char rematchResponse = readCentered()[0];
    clearInput();
    if (rematchResponse == 'y' || rematchResponse == 'Y') {
        battleshipGame.play();
    }
}

    void playSinglePlayerGame() {
        initializeGrid(userGrid);
        initializeGrid(botGrid);

        printSepareted();

        printCentered("Choose placement method: ");
        printCentered("1. Automatic");
        printCentered("2. Manual");

        int choice = std::stoi(readCentered());
        clearInput();

        if (choice == 1) {
            bool satisfied = false;
            AutoPlacement autoPlacement(userGrid);

            while (!satisfied) {
                clearScreen();
                initializeGrid(userGrid);
                autoPlacement.placeShips();
                userGrid.print();

                printCentered("Are you satisfied with the ship placement? (y/n): ");
                char response = readCentered()[0];
                clearInput();
                if (response == 'y' || response == 'Y') {
                    satisfied = true;
                }
            }
        } else {
            ManualPlacement manualPlacement(userGrid);
            manualPlacement.placeShips();
        }

        clearScreen();

        AutoPlacement autoPlacement(botGrid);
        autoPlacement.placeShips();

        printGrids(userGrid, botGrid, "Player 1", "Bot", revealBotGrid);

        bool player1Turn = true;

        while (true) {
            userTurn(userShots, botGrid, userHitCount, player1Turn, shipManager2);
            if (checkWin(botGrid)) {
                clearScreen();
                printGrids(userGrid, botGrid, "Player 1", "Bot", revealBotGrid);

                for(int i = 0; i < 3; i++)
                    cout << "\n";
                printCentered("Congratulations! You have won!\n");
                break;
            }

            computerTurn();
            if (checkWin(userGrid)) {
                clearScreen();
                printGrids(userGrid, botGrid, "Player 1", "Bot", revealBotGrid);

                for(int i = 0; i < 3; i++)
                    cout << "\n";
                printCentered("Game over! The computer has won!\n");
                break;
            }
        }

        endGameSummarySinglePlayer();
    }

    void computerTurn() {
        int x, y;
        bool validMove = false;
        std::stringstream ss;
        delay(2000);

        while (!validMove) {
            x = rand() % GRID_SIZE;
            y = rand() % GRID_SIZE;

            if (std::find(botShots.begin(), botShots.end(), std::make_pair(x, y)) != botShots.end()) {
                continue;
            }

            botShots.push_back(std::make_pair(x, y));

            if (userGrid.grid[x][y] == 'H' || userGrid.grid[x][y] == '*') {
                continue;
            }

            if (userGrid.grid[x][y] != '.') {
                char hitSymbol = userGrid.grid[x][y];
                if (shipManager1.hitShip(hitSymbol)) {
                    shipManager1.markShipAsDestroyed(hitSymbol, userGrid);
                    ss << "Computer hit! Ship " << hitSymbol << " is completely destroyed!\n";
                    //printCentered(ss.str());
                } else {
                    userGrid.grid[x][y] = 'H';
                    ss << "Computer hit! Ship at (" << x << ", " << y << ")!\n";
                    //printCentered(ss.str());
                }

                botHitCount++;

                if (checkWin(userGrid)) {
                    break;
                }
            } else {
                userGrid.grid[x][y] = '*';
                ss << "Computer missed! No ship at (" << x << ", " << y << ").\n";
                //printCentered(ss.str());
                validMove = true;
            }

            clearScreen();
            printGrids(userGrid, botGrid, "Player 1", "Bot", revealBotGrid);
            printCentered(ss.str());
        }
    }

    void userTurn(std::vector<std::pair<int, int>>& playerShots, Grid& opponentGrid, int& playerHitCount, bool& player1Turn, ShipManager& opponentShipManager) {
        int userX, userY;
        BattleshipGame battleshipGame;
        std::string input;
        bool validMove = false;
        std::ostringstream oss;

        while (!validMove) {
            printCentered("Enter coordinates to attack (x y): ");
            input = readCentered();

            if (input == "surrender") {
                handleSurrenderAndRematch(battleshipGame);
            }

            if (input == "SHOW") {
                revealBotGrid = !revealBotGrid;
                clearScreen();
                printGrids(userGrid, botGrid, "Player 1", "Bot", revealBotGrid);
                continue;
            }

            std::istringstream iss(input);
            if (!(iss >> userX >> userY) || userX < 0 || userX >= GRID_SIZE || userY < 0 || userY >= GRID_SIZE) {
                printCentered("Invalid input. Please enter valid coordinates or 'surrender'.\n");
                continue;
            }

            if (std::find(playerShots.begin(), playerShots.end(), std::make_pair(userX, userY)) != playerShots.end()) {
                printCentered("You've already shot at this position. Try again.\n");
                continue;
            }

            playerShots.push_back(std::make_pair(userX, userY));

            if (opponentGrid.grid[userX][userY] != '.') {
                char hitSymbol = opponentGrid.grid[userX][userY];
                if (opponentShipManager.hitShip(hitSymbol)) {
                    opponentShipManager.markShipAsDestroyed(hitSymbol, opponentGrid);
                    oss << "Hit! Ship " << hitSymbol << " is completely destroyed!\n";
                } else {
                    opponentGrid.grid[userX][userY] = 'H';
                    oss << "Hit! Ship at (" << userX << ", " << userY << ")!\n";
                }
                playerHitCount++;
                if (checkWin(opponentGrid)) {
                    break;
                }
            } else {
                opponentGrid.grid[userX][userY] = '*';
                oss << "Missed! No ship at (" << userX << ", " << userY << ").\n";
                validMove = true;
            }

            clearScreen();
            if (player1Turn) {
                printGrids(userGrid, botGrid, "Player 1", "Bot", revealBotGrid);
            } else {
                printGrids(player1Grid, player2Grid, "Player 1", "Player 2", true);
            }
            printCentered(oss.str());
        }
    }

    void endGameSummaryTwoPlayer() {
    std::vector<std::vector<std::string>> table;
    table.push_back({"Player", "Shots", "Hits", "Accuracy (%)"});

    float player1Accuracy = (float)player1HitCount / player1Shots.size() * 100;
    float player2Accuracy = (float)player2HitCount / player2Shots.size() * 100;

    table.push_back({"Player 1", std::to_string(player1Shots.size()), std::to_string(player1HitCount), std::to_string(player1Accuracy)});
    table.push_back({"Player 2", std::to_string(player2Shots.size()), std::to_string(player2HitCount), std::to_string(player2Accuracy)});

    printTableCentered(table);

    if (checkWin(player1Grid)) {
        printCentered("\nCongratulations on Player 1 victory! Would you like to save your result in the leaderboard? (y/n): ");
        char response = readCentered()[0];
        clearInput();
        if (response == 'y' || response == 'Y') {
            saveResult(player1Shots.size(), player1HitCount, player1Accuracy);
        }
    } else if (checkWin(player2Grid)) {
        printCentered("\nCongratulations on Player 2 victory! Would you like to save your result in the leaderboard? (y/n): ");
        char response = readCentered()[0];
        clearInput();
        if (response == 'y' || response == 'Y') {
            saveResult(player2Shots.size(), player2HitCount, player2Accuracy);
        }
    }
    printCentered("Would you like to see the leaderboard? (y/n): ");
    char response = readCentered()[0];
    clearInput();
    if (response == 'y' || response == 'Y') {
        displayLeaderboard();
    }
}

// Функція для виведення підсумків гри для одного гравця
void endGameSummarySinglePlayer() {
    std::vector<std::vector<std::string>> table;
    table.push_back({"Player", "Shots", "Hits", "Accuracy (%)"});

    float userAccuracy = static_cast<float>(userHitCount) / userShots.size() * 100;
    float botAccuracy = static_cast<float>(botHitCount) / botShots.size() * 100;

    std::ostringstream userAccuracyStr, botAccuracyStr;
    userAccuracyStr << std::fixed << std::setprecision(2) << userAccuracy;
    botAccuracyStr << std::fixed << std::setprecision(2) << botAccuracy;

    table.push_back({"Player", std::to_string(userShots.size()), std::to_string(userHitCount), userAccuracyStr.str()});
    table.push_back({"Computer", std::to_string(botShots.size()), std::to_string(botHitCount), botAccuracyStr.str()});

    printTableCentered(table);

    if (checkWin(botGrid)) {
        printCentered("\nCongratulations on your victory! Would you like to save your result in the leaderboard? (y/n): ");
        char response = readCentered()[0];
        clearInput();
        if (response == 'y' || response == 'Y') {
            saveResult(userShots.size(), userHitCount, userAccuracy);
        }
    } else {
        printCentered("Would you like to see the leaderboard? (y/n): ");
        char response = readCentered()[0];
        clearInput();
        if (response == 'y' || response == 'Y') {
            displayLeaderboard();
        }
    }
}

    void saveResult(int shots, int hits, float accuracy) {
        std::ofstream leaderboard("leaderboard.txt", std::ios::app);
        if (!leaderboard) {
            std::cerr << "Error opening leaderboard file.\n";
            return;
        }

        std::string name;
        while (true) {
            printCentered("Enter your name (at least one word): ");
            std::getline(std::cin, name);

            if (!name.empty()) {
                break;
            } else {
                std::cerr << "Invalid name. Please enter your name correctly.\n";
            }
        }

        leaderboard << name << " " << shots << " " << hits << " " << accuracy << "\n";
        leaderboard.close();

        printCentered("Would you like to see the leaderboard? (y/n): ");
        char response = readCentered()[0];
        clearInput();
        if (response == 'y' || response == 'Y') {
            displayLeaderboard();
        }
    }

    void displayLeaderboard() {
    std::ifstream leaderboard("leaderboard.txt");
    if (!leaderboard) {
        std::cerr << "Error opening leaderboard file.\n";
        return;
    }

    struct Player {
        std::string name;
        int shots;
        int hits;
        float accuracy;
    };

    std::vector<Player> players;
    std::string line;

    while (std::getline(leaderboard, line)) {
        std::istringstream iss(line);
        Player player;
        if (iss >> player.name >> player.shots >> player.hits >> player.accuracy) {
            players.push_back(player);
        }
    }
    leaderboard.close();

    std::sort(players.begin(), players.end(), [](const Player& a, const Player& b) {
        return a.accuracy > b.accuracy;
    });

    std::vector<std::vector<std::string>> table;
    table.push_back({"Name", "Shots", "Hits", "Accuracy (%)"});

    for (const auto& player : players) {
        std::ostringstream oss;
        oss << std::fixed << std::setprecision(2) << player.accuracy;
        table.push_back({player.name, std::to_string(player.shots), std::to_string(player.hits), std::to_string(player.accuracy)});
    }

    printTableCentered(table);
}

    bool checkWin(const Grid& grid) {
        for (const auto& row : grid.grid) {
            for (char cell : row) {
                if (/*cell == 'A' || cell == 'B' || cell == 'D' ||*/ cell == 'C') {
                    return false;
                }
            }
        }
        return true;
    }
};

int main() {
    BattleshipGame game;
    game.play();
    return 0;
}
